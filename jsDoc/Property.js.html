<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Property.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Property.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//the functions for a property Object
const util = require("./utilities");

class Property {
    /**
     * A Property represents an rdf:Property. It is identified by its IRI
     *
     * @class
     * @param {string} IRI - The compacted IRI of this Property, e.g. "schema:address"
     * @param {object} graph - The underlying data graph to enable the methods of this Property
     */
    constructor(IRI, graph) {
        this.IRI = IRI;
        this.graph = graph;
    }

    /**
     * Retrieves the IRI (@id) of this Property in compact/absolute form
     *
     * @param {boolean} compactForm - (default = false), if true -> return compact IRI -> "schema:address", if false -> return absolute IRI -> "http://schema.org/address"
     * @returns {string} The IRI (@id) of this Property
     */
    getIRI(compactForm = false) {
        if (compactForm) {
            return this.IRI;
        } else {
            return util.toAbsoluteIRI(this.IRI, this.graph.context);
        }
    }

    /**
     * Retrieves the term type of this Property (is always "rdf:Property")
     *
     * @returns {string} The term type of this Property -> "rdf:Property"
     */
    getTermType() {
        return "rdf:Property";
    }

    /**
     * Retrieves the original vocabulary (schema:isPartOf) of this Property
     *
     * @returns {string|null} The vocabulary IRI given by the "schema:isPartOf" of this Property
     */
    getVocabulary() {
        let propertyObj = this.graph.properties[this.IRI];
        if (propertyObj["schema:isPartOf"] !== undefined) {
            return propertyObj["schema:isPartOf"];
        } else {
            return null;
        }
    }

    /**
     * Retrieves the source (dc:source) of this Property
     *
     * @returns {string|null} The source IRI given by the "dc:source" of this Property (null if none)
     */
    getSource() {
        let propertyObj = this.graph.properties[this.IRI];
        if (propertyObj["dc:source"] !== undefined) {
            return propertyObj["dc:source"];
        } else {
            return null;
        }
    }

    /**
     * Retrieves the Property superseding (schema:supersededBy) this Property
     *
     * @returns {string|null} The Property superseding this Property (null if none)
     */
    isSupersededBy() {
        let propertyObj = this.graph.properties[this.IRI];
        if (util.isString(propertyObj["schema:supersededBy"])) {
            return propertyObj["schema:supersededBy"];
        } else {
            return null;
        }
    }

    /**
     * Retrieves the name (rdfs:label) of this Property in a wished language (optional)
     *
     * @param {string} language - (default = "en") the wished language for the name
     * @returns {string|null} The name of this Property (null if not given for specified language)
     */
    getName(language = "en") {
        let nameObj = this.graph.properties[this.IRI]["rdfs:label"];
        if (nameObj === null || nameObj[language] === undefined) {
            return null;
        }
        return nameObj[language];
    }

    /**
     * Retrieves the description (rdfs:comment) of this Property in a wished language (optional)
     *
     * @param {string} language - (default = "en") the wished language for the description
     * @returns {string|null} The description of this Property (null if not given for specified language)
     */
    getDescription(language = "en") {
        let descriptionObj = this.graph.properties[this.IRI]["rdfs:comment"];
        if (descriptionObj === null || descriptionObj[language] === undefined) {
            return null;
        }
        return descriptionObj[language];
    }


    /**
     * Retrieves the explicit/implicit ranges (schema:rangeIncludes) of this Property
     *
     * @param {boolean} implicit - (default = true) retrieves also implicit ranges (inheritance from sub-classes of the ranges)
     * @param {object|null} filter - (default = null) an optional filter for the ranges
     * @returns {Array} The ranges of this Property
     */
    getRanges(implicit = true, filter = null) {
        let propertyObj = this.graph.properties[this.IRI];
        let result = [];
        result.push(... propertyObj["schema:rangeIncludes"]);
        if (implicit === true) {
            //add sub-classes from ranges
            let inferredSubClasses = [];
            for (let i = 0; i &lt; result.length; i++) {
                inferredSubClasses.push(... this.graph.reasoner.inferImplicitSubClasses(result[i]));
            }
            result.push(... inferredSubClasses);
            //remove "null" values from array (if range included data types)
            result = result.filter(function (el) {
                return el !== null;
            });
        }
        return util.applyFilter(util.uniquifyArray(result), filter, this.graph);
    }

    /**
     * Retrieves the explicit/implicit domains (schema:domainIncludes) of this Property
     *
     * @param {boolean} implicit - (default = true) retrieves also implicit domains (inheritance from sub-classes of the domains)
     * @param {object|null} filter - (default = null) an optional filter for the domains
     * @returns {Array} The domains of this Property
     */
    getDomains(implicit = true, filter = null) {
        let propertyObj = this.graph.properties[this.IRI];
        let result = [];
        result.push(... propertyObj["schema:domainIncludes"]);
        if (implicit === true) {
            //add sub-classes from ranges
            let inferredSubClasses = [];
            for (let i = 0; i &lt; result.length; i++) {
                inferredSubClasses.push(... this.graph.reasoner.inferImplicitSubClasses(result[i]));
            }
            result.push(... inferredSubClasses);
        }
        return util.applyFilter(util.uniquifyArray(result), filter, this.graph);
    }

    /**
     * Retrieves the explicit/implicit super-properties (rdfs:subPropertyOf) of this Property
     *
     * @param {boolean} implicit - (default = true) retrieves also implicit super-properties (recursive from super-properties)
     * @param {object|null} filter - (default = null) an optional filter for the super-properties
     * @returns {Array} The super-properties of this Property
     */
    getSuperProperties(implicit = true, filter = null) {
        let propertyObj = this.graph.properties[this.IRI];
        let result = [];

        if (implicit === true) {
            result.push(... this.graph.reasoner.inferSuperProperties(this.IRI));
        } else {
            result.push(... propertyObj["rdfs:subPropertyOf"]);
        }
        return util.applyFilter(util.uniquifyArray(result), filter, this.graph);
    }

    /**
     * Retrieves the explicit/implicit sub-properties (soa:superPropertyOf) of this Property
     *
     * @param {boolean} implicit - (default = true) retrieves also implicit sub-properties (recursive from sub-properties)
     * @param {object|null} filter - (default = null) an optional filter for the sub-properties
     * @returns {Array} The sub-properties of this Property
     */
    getSubProperties(implicit = true, filter = null) {
        let propertyObj = this.graph.properties[this.IRI];
        let result = [];

        if (implicit === true) {
            result.push(... this.graph.reasoner.inferSubProperties(this.IRI));
        } else {
            result.push(... propertyObj["soa:superPropertyOf"]);
        }
        return util.applyFilter(util.uniquifyArray(result), filter, this.graph);
    }

    /**
     * Generates a string representation of this Property (Based on its JSON representation)
     *
     * @returns {string} The string representation of this Property
     */
    toString() {
        return JSON.stringify(this.toJSON(false, null), null, 2);
    }

    /**
     * Generates an explicit/implicit JSON representation of this Property.
     *
     * @param {boolean} implicit - (default = true) includes also implicit data (e.g. domains, ranges, etc.)
     * @param {object|null} filter - (default = null) an optional filter for the generated data
     * @returns {object} The JSON representation of this Class
     */
    toJSON(implicit = true, filter = null) {
        let result = {};
        result["id"] = this.getIRI(true);
        result["IRI"] = this.getIRI();
        result["type"] = this.getTermType();
        result["vocabulary"] = this.getVocabulary();
        result["source"] = this.getSource();
        result["supersededBy"] = this.isSupersededBy();
        result["name"] = this.getName();
        result["description"] = this.getDescription();
        result["ranges"] = this.getRanges(implicit, filter);
        result["domains"] = this.getDomains(implicit, filter);
        result["superProperties"] = this.getSuperProperties(implicit, filter);
        result["subProperties"] = this.getSubProperties(implicit, filter);
        return result;
    }
}

module.exports = Property;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Class.html">Class</a></li><li><a href="DataType.html">DataType</a></li><li><a href="Enumeration.html">Enumeration</a></li><li><a href="EnumerationMember.html">EnumerationMember</a></li><li><a href="Graph.html">Graph</a></li><li><a href="Property.html">Property</a></li><li><a href="ReasoningEngine.html">ReasoningEngine</a></li><li><a href="SDOAdapter.html">SDOAdapter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#applyFilter">applyFilter</a></li><li><a href="global.html#copByVal">copByVal</a></li><li><a href="global.html#curateVocabNode">curateVocabNode</a></li><li><a href="global.html#generateContext">generateContext</a></li><li><a href="global.html#isArray">isArray</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#preProcessVocab">preProcessVocab</a></li><li><a href="global.html#toAbsoluteIRI">toAbsoluteIRI</a></li><li><a href="global.html#toCompactIRI">toCompactIRI</a></li><li><a href="global.html#uniquifyArray">uniquifyArray</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Tue Jan 14 2020 16:04:41 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
